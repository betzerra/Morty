///
/// @Generated by Mockolo
///



import Combine
import EventKit
import Factory
import Foundation


class EKServiceProtocolMock: EKServiceProtocol {
    init() { }
    init(authorizationStatusForEvent: EKAuthorizationStatus) {
        self._authorizationStatusForEvent = authorizationStatusForEvent
    }



    private var _authorizationStatusForEvent: EKAuthorizationStatus!
    var authorizationStatusForEvent: EKAuthorizationStatus {
        get { return _authorizationStatusForEvent }
        set { _authorizationStatusForEvent = newValue }
    }

    private(set) var requestAccessToEventsCallCount = 0
    var requestAccessToEventsHandler: (() async throws -> ())?
    func requestAccessToEvents() async throws {
        requestAccessToEventsCallCount += 1
        if let requestAccessToEventsHandler = requestAccessToEventsHandler {
            try await requestAccessToEventsHandler()
        }
        
    }

    private(set) var eventsCallCount = 0
    var eventsHandler: ((NSPredicate) -> [Event])?
    func events(matching predicate: NSPredicate) -> [Event] {
        eventsCallCount += 1
        if let eventsHandler = eventsHandler {
            return eventsHandler(predicate)
        }
        return [Event]()
    }

    private(set) var calendarsCallCount = 0
    var calendarsHandler: ((EKEntityType) -> [EKCalendar])?
    func calendars(for entityType: EKEntityType) -> [EKCalendar] {
        calendarsCallCount += 1
        if let calendarsHandler = calendarsHandler {
            return calendarsHandler(entityType)
        }
        return [EKCalendar]()
    }

    private(set) var predicateForEventsCallCount = 0
    var predicateForEventsHandler: ((Date, Date, [EKCalendar]?) -> NSPredicate)?
    func predicateForEvents(withStart startDate: Date, end endDate: Date, calendars: [EKCalendar]?) -> NSPredicate {
        predicateForEventsCallCount += 1
        if let predicateForEventsHandler = predicateForEventsHandler {
            return predicateForEventsHandler(startDate, endDate, calendars)
        }
        fatalError("predicateForEventsHandler returns can't have a default value thus its handler must be set")
    }
}

class DefaultsServiceProtocolMock: DefaultsServiceProtocol {
    init() { }
    init(allowedCalendars: [String] = [String]()) {
        self.allowedCalendars = allowedCalendars
    }


    private(set) var allowedCalendarsSetCallCount = 0
    var allowedCalendars: [String] = [String]() { didSet { allowedCalendarsSetCallCount += 1 } }
}

class EventServiceProtocolMock: EventServiceProtocol {
    init() { }
    init(events: [Event] = [Event]()) {
        self.events = events
    }


    private(set) var fetchEventsCallCount = 0
    var fetchEventsHandler: (() -> [Event])?
    func fetchEvents() -> [Event] {
        fetchEventsCallCount += 1
        if let fetchEventsHandler = fetchEventsHandler {
            return fetchEventsHandler()
        }
        return [Event]()
    }


    var events: [Event] = [Event]()

    var eventsFetched: AnyPublisher<[Event], Never> { return self.eventsFetchedSubject.eraseToAnyPublisher() }
    private(set) var eventsFetchedSubject = PassthroughSubject<[Event], Never>()
}

class CalendarServiceProtocolMock: CalendarServiceProtocol {
    init() { }
    init(allowedCalendars: Set<String> = Set<String>()) {
        self.allowedCalendars = allowedCalendars
    }


    private(set) var fetchCalendarsCallCount = 0
    var fetchCalendarsHandler: (() -> [CalendarItem])?
    func fetchCalendars() -> [CalendarItem] {
        fetchCalendarsCallCount += 1
        if let fetchCalendarsHandler = fetchCalendarsHandler {
            return fetchCalendarsHandler()
        }
        return [CalendarItem]()
    }

    private(set) var allowedCalendarsSetCallCount = 0
    var allowedCalendars: Set<String> = Set<String>() { didSet { allowedCalendarsSetCallCount += 1 } }

    var allowedCalendarsPublisher: AnyPublisher<Set<String>, Never> { return self.allowedCalendarsPublisherSubject.eraseToAnyPublisher() }
    private(set) var allowedCalendarsPublisherSubject = PassthroughSubject<Set<String>, Never>()
}



